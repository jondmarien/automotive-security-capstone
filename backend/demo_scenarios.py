#!/usr/bin/env python
"""
demo_scenarios.py

Script to run predefined demonstration scenarios for the capstone presentation.
This script provides structured sequences of synthetic events to showcase
the detection capabilities of the system in a controlled manner.
"""

import argparse
import asyncio
import logging
import json
import os
from datetime import datetime
from typing import Dict, List
import random

# Import signal constants
from utils.signal_constants import MANUFACTURER_PARAMETERS

# Import synthetic event generators
from cli_dashboard_detection_adapter import (
    generate_synthetic_key_fob_event,
    generate_synthetic_replay_attack,
    generate_synthetic_jamming_attack,
    generate_synthetic_brute_force_attack,
)


class DemonstrationScenario:
    """Base class for demonstration scenarios."""

    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.events = []

    async def setup(self):
        """Set up the scenario. Override in subclasses."""
        pass

    async def run(self):
        """Run the scenario. Override in subclasses."""
        pass

    async def cleanup(self):
        """Clean up after the scenario. Override in subclasses."""
        pass

    def get_events(self) -> List[Dict]:
        """Get the events generated by this scenario."""
        return self.events


class NormalOperationScenario(DemonstrationScenario):
    """Demonstrates normal key fob operation."""

    def __init__(self):
        super().__init__(
            "Normal Operation",
            "Demonstrates normal key fob operation with lock/unlock sequences.",
        )

    async def run(self):
        # Generate a sequence of normal key fob operations
        manufacturers = list(MANUFACTURER_PARAMETERS.keys())
        selected_manufacturer = random.choice(manufacturers)

        # Lock sequence
        logging.info(f"Generating lock event for {selected_manufacturer}")
        lock_event = generate_synthetic_key_fob_event("benign")
        lock_event["type"] = "RF Lock"
        lock_event["details"] = "Detected valid lock signal."
        lock_event["source"] = selected_manufacturer
        self.events.append(lock_event)
        await asyncio.sleep(2.0)

        # Wait a bit
        await asyncio.sleep(3.0)

        # Unlock sequence
        logging.info(f"Generating unlock event for {selected_manufacturer}")
        unlock_event = generate_synthetic_key_fob_event("benign")
        unlock_event["type"] = "RF Unlock"
        unlock_event["details"] = "Detected valid unlock signal."
        unlock_event["source"] = selected_manufacturer
        self.events.append(unlock_event)

        return self.events


class ReplayAttackScenario(DemonstrationScenario):
    """Demonstrates a replay attack sequence."""

    def __init__(self):
        super().__init__(
            "Replay Attack",
            "Demonstrates a replay attack where an attacker captures and replays a legitimate signal.",
        )

    async def run(self):
        # First, generate a legitimate unlock event
        logging.info("Generating legitimate unlock event")
        legitimate_event = generate_synthetic_key_fob_event("benign")
        legitimate_event["type"] = "RF Unlock"
        legitimate_event["details"] = "Detected valid unlock signal."
        self.events.append(legitimate_event)
        await asyncio.sleep(2.0)

        # Wait a bit to simulate time passing
        await asyncio.sleep(3.0)

        # Now simulate the replay attack
        logging.info("Generating replay attack events")
        for i in range(3):  # Multiple replay attempts
            replay_event = generate_synthetic_replay_attack(legitimate_event)
            self.events.append(replay_event)
            await asyncio.sleep(1.0)  # Faster replay timing

        return self.events


class JammingAttackScenario(DemonstrationScenario):
    """Demonstrates a jamming attack sequence."""

    def __init__(self):
        super().__init__(
            "Jamming Attack",
            "Demonstrates a jamming attack that prevents legitimate key fob signals from reaching the vehicle.",
        )

    async def run(self):
        # Generate a sequence of jamming events
        logging.info("Generating jamming attack sequence")
        for step in range(5):
            jamming_event = generate_synthetic_jamming_attack(step)
            self.events.append(jamming_event)
            await asyncio.sleep(0.8)

        return self.events


class BruteForceAttackScenario(DemonstrationScenario):
    """Demonstrates a brute force attack sequence."""

    def __init__(self):
        super().__init__(
            "Brute Force Attack",
            "Demonstrates a brute force attack that attempts multiple code combinations to unlock a vehicle.",
        )

    async def run(self):
        # Generate a sequence of brute force events
        logging.info("Generating brute force attack sequence")
        for step in range(6):
            brute_force_event = generate_synthetic_brute_force_attack(step)
            self.events.append(brute_force_event)
            await asyncio.sleep(0.5)  # Brute force attempts happen rapidly

        return self.events


class ComprehensiveDemoScenario(DemonstrationScenario):
    """Runs a comprehensive demonstration of all attack types."""

    def __init__(self):
        super().__init__(
            "Comprehensive Demo",
            "Demonstrates all attack types in sequence with clear transitions.",
        )

    async def run(self):
        # Run normal operation first
        logging.info("Starting normal operation demonstration")
        normal_scenario = NormalOperationScenario()
        normal_events = await normal_scenario.run()
        self.events.extend(normal_events)

        # Add a transition message
        logging.info("Transitioning to replay attack demonstration")
        await asyncio.sleep(2.0)

        # Run replay attack
        replay_scenario = ReplayAttackScenario()
        replay_events = await replay_scenario.run()
        self.events.extend(replay_events)

        # Add a transition message
        logging.info("Transitioning to jamming attack demonstration")
        await asyncio.sleep(2.0)

        # Run jamming attack
        jamming_scenario = JammingAttackScenario()
        jamming_events = await jamming_scenario.run()
        self.events.extend(jamming_events)

        # Add a transition message
        logging.info("Transitioning to brute force attack demonstration")
        await asyncio.sleep(2.0)

        # Run brute force attack
        brute_force_scenario = BruteForceAttackScenario()
        brute_force_events = await brute_force_scenario.run()
        self.events.extend(brute_force_events)

        logging.info("Comprehensive demonstration complete")
        return self.events


async def run_demo_scenario(scenario_name: str, output_file: str = None):
    """
    Run a specific demonstration scenario.

    Args:
        scenario_name: Name of the scenario to run
        output_file: Optional file to save events to
    """
    # Map scenario names to classes
    scenarios = {
        "normal": NormalOperationScenario(),
        "replay": ReplayAttackScenario(),
        "jamming": JammingAttackScenario(),
        "brute_force": BruteForceAttackScenario(),
        "comprehensive": ComprehensiveDemoScenario(),
    }

    if scenario_name not in scenarios:
        logging.error(f"Unknown scenario: {scenario_name}")
        print(f"Unknown scenario: {scenario_name}")
        print(f"Available scenarios: {', '.join(scenarios.keys())}")
        return

    # Run the selected scenario
    scenario = scenarios[scenario_name]
    logging.info(f"Running scenario: {scenario.name}")
    print(f"\nRunning demonstration scenario: {scenario.name}")
    print(f"Description: {scenario.description}\n")

    # Run the scenario
    events = await scenario.run()

    # Save events to file if requested
    if output_file:
        os.makedirs(os.path.dirname(output_file), exist_ok=True)
        with open(output_file, "w") as f:
            json.dump(events, f, indent=2)
        logging.info(f"Saved {len(events)} events to {output_file}")
        print(f"Saved {len(events)} events to {output_file}")

    logging.info(f"Scenario complete: {scenario.name}")
    print(f"\nScenario complete: {scenario.name}")
    print(f"Generated {len(events)} events")

    return events


def setup_logging():
    """Set up logging configuration."""
    log_dir = os.path.join("logs")
    os.makedirs(log_dir, exist_ok=True)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = os.path.join(log_dir, f"demo_scenario_{timestamp}.log")

    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        handlers=[logging.FileHandler(log_file), logging.StreamHandler()],
    )


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="Run demonstration scenarios")
    parser.add_argument(
        "--scenario",
        type=str,
        default="comprehensive",
        choices=["normal", "replay", "jamming", "brute_force", "comprehensive"],
        help="Scenario to run (default: comprehensive)",
    )
    parser.add_argument("--output", type=str, help="File to save events to (optional)")
    return parser.parse_args()


async def main():
    """Main entry point."""
    # Set up logging
    setup_logging()

    # Parse arguments
    args = parse_args()

    # Run the selected scenario
    await run_demo_scenario(args.scenario, args.output)


if __name__ == "__main__":
    asyncio.run(main())
